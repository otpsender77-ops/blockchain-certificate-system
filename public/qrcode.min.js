// QR Code Library - Local Fallback
// This is a simplified QR code implementation for offline use

(function(global) {
  'use strict';

  // Simple QR Code implementation
  function QRCode(canvas, text, options) {
    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
    }
    
    if (!canvas) {
      throw new Error('Canvas element not found');
    }

    options = options || {};
    const size = options.width || 200;
    const margin = options.margin || 4;
    const color = options.color || { dark: '#000000', light: '#ffffff' };

    // Create a simple pattern for demonstration
    const ctx = canvas.getContext('2d');
    canvas.width = size;
    canvas.height = size;

    // Clear canvas
    ctx.fillStyle = color.light;
    ctx.fillRect(0, 0, size, size);

    // Draw a simple QR-like pattern
    const cellSize = Math.floor((size - margin * 2) / 25);
    const offset = (size - cellSize * 25) / 2;

    ctx.fillStyle = color.dark;
    
    // Draw corner markers
    drawCornerMarker(ctx, offset, offset, cellSize);
    drawCornerMarker(ctx, offset + cellSize * 18, offset, cellSize);
    drawCornerMarker(ctx, offset, offset + cellSize * 18, cellSize);

    // Draw a simple pattern based on text hash
    const hash = simpleHash(text);
    for (let i = 0; i < 25; i++) {
      for (let j = 0; j < 25; j++) {
        if (shouldFillCell(hash, i, j)) {
          ctx.fillRect(offset + j * cellSize, offset + i * cellSize, cellSize, cellSize);
        }
      }
    }

    return canvas;
  }

  function drawCornerMarker(ctx, x, y, cellSize) {
    // Outer square
    ctx.fillRect(x, y, cellSize * 7, cellSize * 7);
    ctx.fillStyle = ctx.canvas.style.backgroundColor || '#ffffff';
    ctx.fillRect(x + cellSize, y + cellSize, cellSize * 5, cellSize * 5);
    ctx.fillStyle = '#000000';
    ctx.fillRect(x + cellSize * 2, y + cellSize * 2, cellSize * 3, cellSize * 3);
  }

  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }

  function shouldFillCell(hash, row, col) {
    // Skip corner markers
    if ((row < 9 && col < 9) || (row < 9 && col > 15) || (row > 15 && col < 9)) {
      return false;
    }
    
    // Create a pattern based on hash
    const seed = (hash + row * 25 + col) % 100;
    return seed > 50;
  }

  // QRCode.toCanvas method
  QRCode.toCanvas = function(canvas, text, options, callback) {
    try {
      const result = new QRCode(canvas, text, options);
      if (callback) {
        callback(null, result);
      }
      return Promise.resolve(result);
    } catch (error) {
      if (callback) {
        callback(error);
      }
      return Promise.reject(error);
    }
  };

  // QRCode.toDataURL method
  QRCode.toDataURL = function(text, options, callback) {
    const canvas = document.createElement('canvas');
    try {
      new QRCode(canvas, text, options);
      const dataURL = canvas.toDataURL();
      if (callback) {
        callback(null, dataURL);
      }
      return Promise.resolve(dataURL);
    } catch (error) {
      if (callback) {
        callback(error);
      }
      return Promise.reject(error);
    }
  };

  // Export to global scope
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = QRCode;
  } else {
    global.QRCode = QRCode;
  }

})(typeof window !== 'undefined' ? window : this);
